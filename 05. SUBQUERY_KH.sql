/*
    < SUBQUERY >
    하나의 SQL문 안에 포함된 또 다른 SQL문

*/

-- 간단 서브쿼리 예시1
-- 노옹철 사원과 같은 부서원들 조회
SELECT DEPT_CODE
FROM EMPLOYEE
WHERE EMP_NAME = '노옹철';

SELECT EMP_NAME
FROM EMPLOYEE
WHERE DEPT_CODE = 'D9';

-- 합치기
SELECT EMP_NAME
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '노옹철');

-- 간단 서브쿼리 예시2
-- 전 직원의 평균 급여보다 더 많은 급여를 받고 있는 직원 조회
SELECT AVG(SALARY)
FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3047663;

SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= (SELECT AVG(SALARY)
                FROM EMPLOYEE);

/*
    < SUBQUERY 구분 >
    서브쿼리를 수행한 결과값이 몇 행 몇 열이냐에 따라서 분류됨
    
    1. 단일행 서브쿼리 : 서브쿼리의 조회 결과 값의 개수가 1개인 경우 
    2. 다중행 서브쿼리 : 서브쿼리의 조회 결과 값의 행수가 여러 행인 경우
    3. 다중열 서브쿼리 : 서브쿼리의 조회 결과 값이 1행이지만 Column이 여러 열인 경우
    4. 다중행 다중열 서브쿼리 : 서브쿼리의 조회 결과값이 여러 행 여러 열일 

*/

-- 1. 단일행 서브쿼리
-- 1) 전 직원의 평균 급여보다 급여를 적게 받는 직원들의 이름, 직급코드, 급여 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY <= (SELECT AVG(SALARY) FROM EMPLOYEE)
ORDER BY 3;

-- 2) 최저 급여를 받는 직원의 사번, 이름, 직급코드, 급여, 입사일 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY, HIRE_DATE
FROM EMPLOYEE
WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);

-- 3) 노옹철 사원의 급여보다 많이 받는 사원의 사번, 이름, 부서코드, 직급코드, 급여 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '노옹철');

-- * 서브쿼리는 WHERE, SELECT, FROM, HAVING 등등 다양한 곳에서 사용 가능
-- 4) 부서별 급여합이 가장 큰 부서의 부서코드, 급여합 조회
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE 
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY)) FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 5) 전지연 사원이 속해있는 부서원들 조회 (단, 전지연은 제외)
SELECT EMP_NAME, PHONE, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '전지연')
AND EMP_NAME != '전지연';


-- 2. 다중행 서브쿼리
-- IN / NOT IN (SUBQUERY) : 여러 개의 결과값 중에서 한 개라도 일치하는 값이 있다면 혹은 없다면 이라는 의미
-- > ANY / < ANY (SUBQUERY) : 여러 개의 결과값 중 한 개라도 클 경우(가장 작은 값보다 크냐?), 작을 경우(가장 큰 값보다 작냐?)라는 의미
-- > ALL / < ALL (SUBQUERY) : 여러 개의 결과값의 모든 값보다 큰 경우(가장 큰 값보다 크냐?), 작은 경우(가장 작은 값보다 작냐?)라는 의미    
-- 1.1) 각 부서별 최고급여를 받는 직원의 이름, 직급코드, 부서코드, 급여 조회
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY IN (SELECT MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 1.2) 사수에 해당하는 직원에 대한 사번, 이름, 부서코드, 구분(사수/사원) 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, '사수' 구분
FROM EMPLOYEE
WHERE EMP_ID IN (SELECT DISTINCT MANAGER_ID FROM EMPLOYEE WHERE MANAGER_ID IS NOT NULL);

-- 1.3) 부사수 조회    
SELECT EMP_ID, EMP_NAME, DEPT_CODE, '부사수' 구분
FROM EMPLOYEE
WHERE EMP_ID NOT IN (SELECT DISTINCT MANAGER_ID FROM EMPLOYEE WHERE MANAGER_ID IS NOT NULL);

-- 1.4) 전체 조회 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, '사수' 구분
FROM EMPLOYEE
WHERE EMP_ID IN (SELECT DISTINCT MANAGER_ID FROM EMPLOYEE WHERE MANAGER_ID IS NOT NULL)
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, '부사수' 구분
FROM EMPLOYEE
WHERE EMP_ID NOT IN (SELECT DISTINCT MANAGER_ID FROM EMPLOYEE WHERE MANAGER_ID IS NOT NULL);

SELECT EMP_ID, EMP_NAME, DEPT_CODE, CASE WHEN EMP_ID IN (SELECT DISTINCT MANAGER_ID FROM EMPLOYEE WHERE MANAGER_ID IS NOT NULL)
                                        THEN '사수'
                                        ELSE '사원'
                                        END 구분
FROM EMPLOYEE;

-- 2.1) 대리 직급임에도 불구하고 과장 직급들의 최소 급여보다 많이 받는 직원 조회
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE
AND SALARY > (SELECT MIN(SALARY) FROM EMPLOYEE JOIN JOB USING (JOB_CODE) WHERE JOB_NAME = '과장')
AND JOB_NAME = '대리'
ORDER BY 4;

SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE
AND SALARY > ANY (SELECT SALARY FROM EMPLOYEE JOIN JOB USING (JOB_CODE) WHERE JOB_NAME = '과장')
AND JOB_NAME = '대리'
ORDER BY 4;

-- 2.2) 과장 직급이지만 차장 직급의 최대 급여보다 더 많이 받는 직원
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE JOB_NAME = '과장'
AND SALARY > ALL (SELECT SALARY FROM EMPLOYEE JOIN JOB USING (JOB_CODE) WHERE JOB_NAME = '차장');

-- 3. 다중열 서브쿼리
-- 3.1) 하이유 사원과 같은 부서코드, 같은 직급코드에 해당하는 사원 조회
-- 단일행  
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '하이유')
AND JOB_CODE = (SELECT JOB_CODE FROM EMPLOYEE WHERE EMP_NAME = '하이유');

-- 다중열
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) = (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE EMP_NAME = '하이유');

-- 3.2) 박나라 사원과 직급코드가 일치하면서 같은 사수를 가지고 있는 사원 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, MANAGER_ID
FROM EMPLOYEE
WHERE (MANAGER_ID, JOB_CODE) = (SELECT MANAGER_ID, JOB_CODE FROM EMPLOYEE WHERE EMP_NAME = '박나라');

-- 4. 다중행 다중열 서브쿼리  
-- 4.1) 각 직급별 최저 급여를 받는 사원들 조회
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE (JOB_CODE, SALARY) IN (SELECT JOB_CODE, MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE)
ORDER BY 2;

-- 4.2) 각 부서별 최저 급여를 받는 사원들 조회
-- IN은 = 비교라 NULL값이 안 보임 ~ 그래서 NVL로 비교할 수 있게 임의의 값 집어넣어줌    
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE (NVL(DEPT_CODE, 'NO'), SALARY) IN (SELECT NVL(DEPT_CODE, 'NO'), MIN(SALARY) FROM EMPLOYEE GROUP BY NVL(DEPT_CODE, 'NO'))
ORDER BY 2;

-- 5. 인라인 뷰 (INLINE - VIEW) : FROM 절에 서브쿼리, 서브쿼리를 수행한 결과를 테이블 대신에 사용
-- 5.1) 연봉이 3000만원 초과인 사원 조회
SELECT EMP_ID, EMP_NAME, SALARY*12 연봉, DEPT_CODE
FROM EMPLOYEE
WHERE SALARY*12 > 30000000;

SELECT EMP_NAME, 연봉, DEPT_CODE
FROM (SELECT EMP_ID, EMP_NAME, SALARY*12 연봉, DEPT_CODE FROM EMPLOYEE)
WHERE 연봉 > 30000000;

-- 5.2) TOP-N 분석
-- 전 직원 중 급여가 가장 높은 상위 5명 순위, 이름, 급여 조회
SELECT ROWNUM 순위, DEPT_TITLE, E.*
FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC) E
JOIN DEPARTMENT D ON (DEPT_CODE = DEPT_ID)
WHERE ROWNUM <= 5;

-- 각 부서별 평균 급여가 가장 높은 상위 3부서
SELECT ROWNUM 순위, DEPT_CODE, ROUND(평균급여)
FROM (SELECT DEPT_CODE, AVG(SALARY) 평균급여 FROM EMPLOYEE GROUP BY DEPT_CODE ORDER BY 2 DESC) E
WHERE ROWNUM <= 3;

-- 5.3) RANK OVER / DENSE_RANK OVER위
-- 사원별 급여가 높은 순대로 순위를 매겨서 사원명, 급여, 순위
SELECT EMP_NAME, SALARY, /*DENSE_*/RANK() OVER(ORDER BY SALARY DESC) 순위
FROM EMPLOYEE;

-- 상위 5명만 조회
SELECT *
FROM (SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) 순위 FROM EMPLOYEE) E
WHERE 순위 <= 5;







